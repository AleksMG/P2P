<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ì–æ–º–æ—Ñ–æ–Ω–∏—á–µ—Å–∫–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ - –ü–æ–ª–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #0a0a0a;
            color: #00ff00;
        }
        .container {
            background: #111;
            padding: 20px;
            border: 1px solid #333;
            border-radius: 5px;
        }
        h1, h2 {
            color: #00ff00;
            text-align: center;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #333;
            background: #1a1a1a;
        }
        .success {
            border-color: #00ff00;
            color: #00ff00;
        }
        .error {
            border-color: #ff0000;
            color: #ff0000;
        }
        textarea, input, button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #000;
            color: #00ff00;
            border: 1px solid #333;
            font-family: 'Courier New', monospace;
        }
        button {
            background: #002200;
            cursor: pointer;
        }
        button:hover {
            background: #004400;
        }
        .result {
            margin-top: 20px;
            padding: 15px;
            background: #1a1a1a;
            border: 1px solid #333;
        }
        .key-display {
            word-break: break-all;
            font-size: 12px;
            background: #000;
            padding: 10px;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê –ì–æ–º–æ—Ñ–æ–Ω–∏—á–µ—Å–∫–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ - –ü–æ–ª–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è</h1>
        
        <div class="status" id="status">–°—Ç–∞—Ç—É—Å: –û–∂–∏–¥–∞–Ω–∏–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–ª—é—á–µ–π...</div>

        <h2>üîë –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–µ–π (1024-–±–∏—Ç–Ω—ã–µ –ø—Ä–æ—Å—Ç—ã–µ —á–∏—Å–ª–∞)</h2>
        <button onclick="generateKeys()">–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤—ã–µ –∫–ª—é—á–∏</button>
        
        <div id="keyDisplay">
            <p><strong>–ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á (n):</strong></p>
            <div class="key-display" id="publicKey">-</div>
            
            <p><strong>–°–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á (p):</strong></p>
            <div class="key-display" id="privateKeyP">-</div>
            
            <p><strong>–°–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á (q):</strong></p>
            <div class="key-display" id="privateKeyQ">-</div>
        </div>

        <h2>üì§ –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞</h2>
        <textarea id="textToEncrypt" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è..." rows="4"></textarea>
        <button onclick="encryptText()">–ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—Å—Ç</button>
        
        <div id="encryptionResult" class="result" style="display: none;">
            <p><strong>–®–∏—Ñ—Ä–æ—Ç–µ–∫—Å—Ç (hex):</strong></p>
            <div class="key-display" id="ciphertextHex"></div>
        </div>

        <h2>üì• –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞</h2>
        <textarea id="cipherToDecrypt" placeholder="–í–≤–µ–¥–∏—Ç–µ hex-—Å—Ç—Ä–æ–∫—É —à–∏—Ñ—Ä–æ—Ç–µ–∫—Å—Ç–∞..." rows="4"></textarea>
        <button onclick="decryptText()">–î–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—Å—Ç</button>
        
        <div id="decryptionResult" class="result" style="display: none;">
            <p><strong>–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç:</strong></p>
            <div class="key-display" id="decryptedText"></div>
        </div>

        <h2>üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</h2>
        <div id="stats">
            <p>–î–ª–∏–Ω–∞ –∫–ª—é—á–∞: <span id="keyLength">0</span> –±–∏—Ç</p>
            <p>–í—Ä–µ–º—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: <span id="genTime">0</span> –º—Å</p>
            <p>–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è: <span id="expansion">1:4</span></p>
        </div>
    </div>

    <script>
        class PrimeGenerator {
            constructor() {
                this.SMALL_PRIMES = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37];
            }

            isProbablyPrime(n, k = 20) {
                if (n <= 1n) return false;
                if (n <= 3n) return true;
                if (n % 2n === 0n) return false;

                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ –º–∞–ª—ã–º –ø—Ä–æ—Å—Ç—ã–º —á–∏—Å–ª–∞–º
                for (const p of this.SMALL_PRIMES) {
                    if (n % BigInt(p) === 0n && n !== BigInt(p)) {
                        return false;
                    }
                }

                // –¢–µ—Å—Ç –ú–∏–ª–ª–µ—Ä–∞-–†–∞–±–∏–Ω–∞
                let d = n - 1n;
                let s = 0n;
                while (d % 2n === 0n) {
                    d /= 2n;
                    s++;
                }

                for (let i = 0; i < k; i++) {
                    const a = this.getRandomBigInt(2n, n - 2n);
                    let x = this.modExp(a, d, n);

                    if (x === 1n || x === n - 1n) {
                        continue;
                    }

                    let continueLoop = false;
                    for (let j = 0n; j < s - 1n; j++) {
                        x = this.modExp(x, 2n, n);
                        if (x === n - 1n) {
                            continueLoop = true;
                            break;
                        }
                    }

                    if (!continueLoop) {
                        return false;
                    }
                }

                return true;
            }

            generatePrime(bits) {
                const startTime = Date.now();
                let candidate;
                let attempts = 0;

                do {
                    attempts++;
                    candidate = this.getRandomBigInt(
                        2n ** BigInt(bits - 1),
                        2n ** BigInt(bits) - 1n
                    );

                    // –î–µ–ª–∞–µ–º –Ω–µ—á–µ—Ç–Ω—ã–º
                    if (candidate % 2n === 0n) {
                        candidate += 1n;
                    }

                    if (attempts % 100 === 0) {
                        this.updateStatus(`–ü–æ–∏—Å–∫ –ø—Ä–æ—Å—Ç–æ–≥–æ —á–∏—Å–ª–∞... –ü–æ–ø—ã—Ç–∫–∞: ${attempts}`);
                    }

                } while (!this.isProbablyPrime(candidate, 20));

                const endTime = Date.now();
                this.updateStatus(`–ü—Ä–æ—Å—Ç–æ–µ —á–∏—Å–ª–æ –Ω–∞–π–¥–µ–Ω–æ –∑–∞ ${attempts} –ø–æ–ø—ã—Ç–æ–∫, ${endTime - startTime}–º—Å`);
                
                return candidate;
            }

            getRandomBigInt(min, max) {
                const range = max - min;
                const bits = range.toString(2).length;
                let result;

                do {
                    const randomBytes = new Uint8Array(Math.ceil(bits / 8));
                    crypto.getRandomValues(randomBytes);
                    
                    let randomValue = 0n;
                    for (const byte of randomBytes) {
                        randomValue = (randomValue << 8n) | BigInt(byte);
                    }

                    result = min + (randomValue % range);
                } while (result > max);

                return result;
            }

            modExp(base, exponent, modulus) {
                if (modulus === 1n) return 0n;
                let result = 1n;
                base = base % modulus;
                
                while (exponent > 0n) {
                    if (exponent % 2n === 1n) {
                        result = (result * base) % modulus;
                    }
                    exponent = exponent >> 1n;
                    base = (base * base) % modulus;
                }
                return result;
            }

            updateStatus(message) {
                document.getElementById('status').textContent = '–°—Ç–∞—Ç—É—Å: ' + message;
            }
        }

        class HomophonicCipher {
            constructor() {
                this.primeGenerator = new PrimeGenerator();
                this.p = null;
                this.q = null;
                this.n = null;
            }

            async generateKeys(bits = 256) {
                const startTime = Date.now();
                
                this.updateStatus('–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–µ—Ä–≤–æ–≥–æ –ø—Ä–æ—Å—Ç–æ–≥–æ —á–∏—Å–ª–∞...');
                this.p = this.primeGenerator.generatePrime(bits);
                
                this.updateStatus('–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Ç–æ—Ä–æ–≥–æ –ø—Ä–æ—Å—Ç–æ–≥–æ —á–∏—Å–ª–∞...');
                this.q = this.primeGenerator.generatePrime(bits);
                
                this.n = this.p * this.q;
                
                const endTime = Date.now();
                this.updateStatus(`–ö–ª—é—á–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã –∑–∞ ${endTime - startTime}–º—Å`);
                
                this.displayKeys();
                return { p: this.p, q: this.q, n: this.n };
            }

            encryptByte(byte) {
                if (!this.n) throw new Error('–ö–ª—é—á–∏ –Ω–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã');
                
                const m = BigInt(byte);
                const r = this.primeGenerator.getRandomBigInt(2n, this.n - 1n);
                
                // c = r¬≤ * (-1)^m mod n
                const rSquared = this.primeGenerator.modExp(r, 2n, this.n);
                const cipher = (m === 1n) ? (this.n - rSquared) % this.n : rSquared;
                
                return cipher;
            }

            decryptNumber(cipher) {
                if (!this.p || !this.q) throw new Error('–°–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω');
                
                const c = BigInt(cipher);
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ c –∫–≤–∞–¥—Ä–∞—Ç–∏—á–Ω—ã–º –≤—ã—á–µ—Ç–æ–º
                const legendreP = this.primeGenerator.modExp(c, (this.p - 1n) / 2n, this.p);
                const legendreQ = this.primeGenerator.modExp(c, (this.q - 1n) / 2n, this.q);
                
                return (legendreP === 1n && legendreQ === 1n) ? 0 : 1;
            }

            async encryptText(text) {
                const encoder = new TextEncoder();
                const data = encoder.encode(text);
                const encrypted = [];

                for (let i = 0; i < data.length; i++) {
                    const byte = data[i];
                    for (let bitPos = 7; bitPos >= 0; bitPos--) {
                        const bit = (byte >> bitPos) & 1;
                        const cipher = this.encryptByte(bit);
                        encrypted.push(cipher.toString(16).padStart(64, '0'));
                    }
                    
                    if (i % 10 === 0) {
                        this.updateStatus(`–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ... ${Math.round((i / data.length) * 100)}%`);
                        await this.delay(0);
                    }
                }

                return encrypted.join('');
            }

            async decryptText(hexString) {
                const numbers = [];
                for (let i = 0; i < hexString.length; i += 64) {
                    const hexChunk = hexString.substr(i, 64);
                    numbers.push(BigInt('0x' + hexChunk));
                }

                const bits = [];
                for (let i = 0; i < numbers.length; i++) {
                    bits.push(this.decryptNumber(numbers[i]));
                    
                    if (i % 80 === 0) {
                        this.updateStatus(`–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ... ${Math.round((i / numbers.length) * 100)}%`);
                        await this.delay(0);
                    }
                }

                // Convert bits to bytes
                const bytes = new Uint8Array(Math.ceil(bits.length / 8));
                for (let i = 0; i < bits.length; i += 8) {
                    let byte = 0;
                    for (let j = 0; j < 8; j++) {
                        if (i + j < bits.length) {
                            byte = (byte << 1) | bits[i + j];
                        }
                    }
                    bytes[Math.floor(i / 8)] = byte;
                }

                const decoder = new TextDecoder();
                return decoder.decode(bytes).replace(/\0+$/, '');
            }

            displayKeys() {
                document.getElementById('publicKey').textContent = this.n.toString(16);
                document.getElementById('privateKeyP').textContent = this.p.toString(16);
                document.getElementById('privateKeyQ').textContent = this.q.toString(16);
                document.getElementById('keyLength').textContent = this.n.toString(2).length;
            }

            updateStatus(message) {
                document.getElementById('status').textContent = '–°—Ç–∞—Ç—É—Å: ' + message;
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        const cipher = new HomophonicCipher();

        async function generateKeys() {
            try {
                cipher.updateStatus('–ù–∞—á–∞–ª–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–ª—é—á–µ–π...');
                await cipher.generateKeys(128); // 128-–±–∏—Ç–Ω—ã–µ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
                cipher.updateStatus('–ö–ª—é—á–∏ –≥–æ—Ç–æ–≤—ã');
            } catch (error) {
                cipher.updateStatus('–û—à–∏–±–∫–∞: ' + error.message);
            }
        }

        async function encryptText() {
            try {
                const text = document.getElementById('textToEncrypt').value;
                if (!text) {
                    alert('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                    return;
                }

                cipher.updateStatus('–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ...');
                const encrypted = await cipher.encryptText(text);
                
                document.getElementById('ciphertextHex').textContent = encrypted;
                document.getElementById('encryptionResult').style.display = 'block';
                cipher.updateStatus('–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ');
                
            } catch (error) {
                cipher.updateStatus('–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message);
            }
        }

        async function decryptText() {
            try {
                const hexString = document.getElementById('cipherToDecrypt').value;
                if (!hexString) {
                    alert('–í–≤–µ–¥–∏—Ç–µ hex-—Å—Ç—Ä–æ–∫—É');
                    return;
                }

                cipher.updateStatus('–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ...');
                const decrypted = await cipher.decryptText(hexString);
                
                document.getElementById('decryptedText').textContent = decrypted;
                document.getElementById('decryptionResult').style.display = 'block';
                cipher.updateStatus('–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ');
                
            } catch (error) {
                cipher.updateStatus('–û—à–∏–±–∫–∞ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message);
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        window.onload = function() {
            cipher.updateStatus('–°–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞. –°–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –∫–ª—é—á–∏.');
        };
    </script>
</body>
</html>
