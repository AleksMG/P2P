<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Омонофонный шифр на основе поля Галуа</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .panel {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .input-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input, textarea, button {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        textarea {
            min-height: 100px;
            resize: vertical;
            font-family: monospace;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
            font-weight: bold;
        }
        button:hover {
            background-color: #2980b9;
        }
        .output {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            margin-top: 10px;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .key-display {
            font-family: monospace;
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        .explanation {
            margin-top: 20px;
            padding: 15px;
            background-color: #e8f4fc;
            border-left: 4px solid #3498db;
            border-radius: 4px;
        }
        .flex-row {
            display: flex;
            gap: 20px;
        }
        .flex-row > div {
            flex: 1;
        }
        @media (max-width: 768px) {
            .flex-row {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <h1>Омонофонный шифр на основе поля Галуа</h1>
    
    <div class="container">
        <div class="panel">
            <h2>Параметры шифра</h2>
            <div class="flex-row">
                <div class="input-group">
                    <label for="prime">Простое число (модуль поля Галуа):</label>
                    <input type="number" id="prime" value="97" min="11" max="999">
                </div>
                <div class="input-group">
                    <label for="variables">Количество переменных в уравнении:</label>
                    <input type="number" id="variables" value="3" min="2" max="5">
                </div>
            </div>
            <button id="generateKey">Сгенерировать новый ключ</button>
            
            <div class="input-group">
                <label>Текущий ключ (секретные коэффициенты для каждой буквы):</label>
                <div class="key-display" id="keyDisplay">Ключ не сгенерирован</div>
            </div>
        </div>
        
        <div class="panel">
            <h2>Шифрование</h2>
            <div class="input-group">
                <label for="plaintext">Исходный текст (только русские буквы):</label>
                <textarea id="plaintext" placeholder="Введите текст для шифрования">ПРИВЕТ МИР</textarea>
            </div>
            <button id="encryptBtn">Зашифровать</button>
            
            <div class="input-group">
                <label>Результат шифрования (омонофоны):</label>
                <div class="output" id="ciphertextOutput"></div>
            </div>
        </div>
        
        <div class="panel">
            <h2>Дешифрование</h2>
            <div class="input-group">
                <label for="ciphertext">Шифротекст (омонофоны в формате x1,x2,...|...):</label>
                <textarea id="ciphertext" placeholder="Введите шифротекст для дешифрования"></textarea>
            </div>
            <button id="decryptBtn">Дешифровать</button>
            
            <div class="input-group">
                <label>Результат дешифрования:</label>
                <div class="output" id="decryptedOutput"></div>
            </div>
        </div>
        
        <div class="explanation">
            <h3>Как это работает:</h3>
            <p>Каждой букве алфавита соответствует линейное уравнение в поле Галуа GF(p):</p>
            <p>a₁x₁ + a₂x₂ + ... + aₙxₙ ≡ c (mod p)</p>
            <p>где p - простое число, a₁...aₙ - коэффициенты (часть ключа), c - числовой код буквы.</p>
            <p>При шифровании для каждой буквы случайным образом выбирается решение этого уравнения.</p>
            <p>При дешифровании для каждого набора чисел проверяется, какому уравнению (букве) оно удовлетворяет.</p>
            <p>Одна и та же буква шифруется разными наборами чисел (омонофонами), что делает частотный анализ невозможным.</p>
        </div>
    </div>

    <script>
        // Алфавит (русские буквы и пробел)
        const ALPHABET = 'АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ ';
        const ALPHABET_SIZE = ALPHABET.length;
        
        // Элементы DOM
        const primeInput = document.getElementById('prime');
        const variablesInput = document.getElementById('variables');
        const generateKeyBtn = document.getElementById('generateKey');
        const keyDisplay = document.getElementById('keyDisplay');
        const plaintextInput = document.getElementById('plaintext');
        const encryptBtn = document.getElementById('encryptBtn');
        const ciphertextOutput = document.getElementById('ciphertextOutput');
        const ciphertextInput = document.getElementById('ciphertext');
        const decryptBtn = document.getElementById('decryptBtn');
        const decryptedOutput = document.getElementById('decryptedOutput');
        
        // Текущий ключ (коэффициенты уравнений для каждой буквы)
        let currentKey = null;
        
        // Генерация случайного числа в диапазоне [min, max]
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        // Расширенный алгоритм Евклида для нахождения обратного элемента в поле Галуа
        function modInverse(a, mod) {
            let t = 0, newT = 1;
            let r = mod, newR = a;
            
            while (newR !== 0) {
                const quotient = Math.floor(r / newR);
                [t, newT] = [newT, t - quotient * newT];
                [r, newR] = [newR, r - quotient * newR];
            }
            
            if (r > 1) return null; // Обратного элемента не существует
            if (t < 0) t += mod;
            
            return t;
        }
        
        // Генерация нового ключа
        function generateKey() {
            const p = parseInt(primeInput.value);
            const n = parseInt(variablesInput.value);
            
            if (p <= ALPHABET_SIZE) {
                alert(`Простое число должно быть больше ${ALPHABET_SIZE} (размера алфавита)`);
                return;
            }
            
            // Генерируем коэффициенты для каждой буквы
            const key = {};
            
            for (let i = 0; i < ALPHABET_SIZE; i++) {
                const char = ALPHABET[i];
                const coefficients = [];
                
                // Генерируем n-1 случайных коэффициентов
                for (let j = 0; j < n - 1; j++) {
                    coefficients.push(getRandomInt(1, p - 1));
                }
                
                // Последний коэффициент вычисляем так, чтобы уравнение имело решение
                // a₁x₁ + a₂x₂ + ... + aₙxₙ ≡ i (mod p)
                // Выбираем aₙ таким, чтобы он был обратимым по модулю p
                let lastCoefficient;
                do {
                    lastCoefficient = getRandomInt(1, p - 1);
                } while (modInverse(lastCoefficient, p) === null);
                
                coefficients.push(lastCoefficient);
                key[char] = coefficients;
            }
            
            currentKey = { p, n, coefficients: key };
            updateKeyDisplay();
        }
        
        // Обновление отображения ключа
        function updateKeyDisplay() {
            if (!currentKey) {
                keyDisplay.textContent = 'Ключ не сгенерирован';
                return;
            }
            
            let keyText = `p = ${currentKey.p}, n = ${currentKey.n}\n`;
            
            for (const char of ALPHABET) {
                if (char === ' ') {
                    keyText += `[ПРОБЕЛ]: ${currentKey.coefficients[char].join(', ')}\n`;
                } else {
                    keyText += `${char}: ${currentKey.coefficients[char].join(', ')}\n`;
                }
            }
            
            keyDisplay.textContent = keyText;
        }
        
        // Шифрование текста
        function encrypt() {
            if (!currentKey) {
                alert('Сначала сгенерируйте ключ!');
                return;
            }
            
            const text = plaintextInput.value.toUpperCase();
            const { p, n, coefficients } = currentKey;
            let ciphertext = '';
            
            for (const char of text) {
                if (!ALPHABET.includes(char)) {
                    alert(`Недопустимый символ: ${char}. Разрешены только русские буквы и пробел.`);
                    return;
                }
                
                // Получаем коэффициенты для текущей буквы
                const a = coefficients[char];
                const c = ALPHABET.indexOf(char); // Числовое представление буквы
                
                // Генерируем случайные значения для первых n-1 переменных
                const values = [];
                for (let i = 0; i < n - 1; i++) {
                    values.push(getRandomInt(0, p - 1));
                }
                
                // Вычисляем значение последней переменной из уравнения:
                // a₁x₁ + a₂x₂ + ... + aₙxₙ ≡ c (mod p)
                let sum = 0;
                for (let i = 0; i < n - 1; i++) {
                    sum = (sum + a[i] * values[i]) % p;
                }
                
                // Решаем уравнение: aₙxₙ ≡ (c - sum) mod p
                const remainder = (c - sum + p) % p;
                const inv = modInverse(a[n-1], p);
                const lastValue = (remainder * inv) % p;
                
                values.push(lastValue);
                
                // Добавляем омонофон к шифротексту
                if (ciphertext) ciphertext += '|';
                ciphertext += values.join(',');
            }
            
            ciphertextOutput.textContent = ciphertext;
            ciphertextInput.value = ciphertext;
        }
        
        // Дешифрование текста
        function decrypt() {
            if (!currentKey) {
                alert('Сначала сгенерируйте ключ!');
                return;
            }
            
            const ciphertext = ciphertextInput.value;
            const { p, n, coefficients } = currentKey;
            let plaintext = '';
            
            const homophones = ciphertext.split('|');
            
            for (const homophone of homophones) {
                const values = homophone.split(',').map(v => parseInt(v.trim()));
                
                if (values.length !== n) {
                    alert(`Неверное количество значений в омонофоне: ${homophone}. Ожидается ${n} значений.`);
                    return;
                }
                
                // Проверяем, для какой буквы выполняется уравнение
                let found = false;
                
                for (const char of ALPHABET) {
                    const a = coefficients[char];
                    let sum = 0;
                    
                    for (let i = 0; i < n; i++) {
                        sum = (sum + a[i] * values[i]) % p;
                    }
                    
                    const c = ALPHABET.indexOf(char);
                    
                    if (sum === c) {
                        plaintext += char;
                        found = true;
                        break;
                    }
                }
                
                if (!found) {
                    alert(`Не удалось дешифровать омонофон: ${homophone}`);
                    return;
                }
            }
            
            decryptedOutput.textContent = plaintext;
        }
        
        // Назначение обработчиков событий
        generateKeyBtn.addEventListener('click', generateKey);
        encryptBtn.addEventListener('click', encrypt);
        decryptBtn.addEventListener('click', decrypt);
        
        // Генерация ключа при загрузке
        window.addEventListener('load', generateKey);
    </script>
</body>
</html>
