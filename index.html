<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Афинное преобразование + Гомофонный шифр</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #2c3e50;
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #2c3e50;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        .input-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        input, textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
        }
        textarea {
            min-height: 100px;
            resize: vertical;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        button:hover {
            background: #2980b9;
        }
        .output {
            margin-top: 20px;
            padding: 15px;
            background: #ecf0f1;
            border-radius: 6px;
            border-left: 4px solid #3498db;
        }
        .output-title {
            font-weight: 600;
            margin-bottom: 10px;
        }
        .output-content {
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            word-break: break-all;
            padding: 10px;
            background: white;
            border-radius: 4px;
            min-height: 50px;
        }
        .params {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        .algorithm {
            margin-top: 30px;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        .step {
            margin-bottom: 15px;
            padding-left: 20px;
            position: relative;
        }
        .step:before {
            content: "→";
            position: absolute;
            left: 0;
            color: #3498db;
        }
    </style>
</head>
<body>
    <h1>Афинное преобразование + Гомофонный шифр</h1>
    
    <div class="container">
        <div class="panel">
            <h2>Шифрование</h2>
            <div class="input-group">
                <label for="a-param">Параметр a (должен быть взаимно простым с 26):</label>
                <input type="number" id="a-param" value="5" min="1" max="25">
            </div>
            <div class="input-group">
                <label for="b-param">Параметр b:</label>
                <input type="number" id="b-param" value="7" min="0" max="25">
            </div>
            <div class="input-group">
                <label for="plaintext">Исходный текст (только A-Z):</label>
                <textarea id="plaintext">ATTACKATDAWN</textarea>
            </div>
            <button onclick="encrypt()">Зашифровать</button>
            <div class="output">
                <div class="output-title">Результат афинного преобразования:</div>
                <div class="output-content" id="affine-output"></div>
            </div>
            <div class="output">
                <div class="output-title">Зашифрованный текст (гомофоны):</div>
                <div class="output-content" id="ciphertext-output"></div>
            </div>
        </div>
        
        <div class="panel">
            <h2>Дешифрование</h2>
            <div class="input-group">
                <label for="ciphertext">Зашифрованный текст:</label>
                <textarea id="ciphertext"></textarea>
            </div>
            <button onclick="decrypt()">Расшифровать</button>
            <div class="output">
                <div class="output-title">Расшифрованный текст:</div>
                <div class="output-content" id="decrypted-output"></div>
            </div>
        </div>
    </div>
    
    <div class="algorithm">
        <h2>Алгоритм работы</h2>
        <div class="step">Для каждого символа x вычисляется y = (a * x + b) mod 26</div>
        <div class="step">Обратное преобразование: x = a⁻¹ * (y - b) mod 26</div>
        <div class="step">Преобразованный текст разбивается на биграммы (по 2 символа)</div>
        <div class="step">Каждая биграмма заменяется на случайный homophone из S-Box</div>
        <div class="step">При дешифровании homophone преобразуется обратно в биграмму</div>
        <div class="step">Биграммы объединяются в текст и применяется обратное афинное преобразование</div>
    </div>

    <script>
        const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        
        let sBox = null;
        let reverseSBox = null;
        
        // Настоящая афинная перестановка
        function affineEncrypt(char, a, b) {
            const x = ALPHABET.indexOf(char);
            if (x === -1) return char;
            
            const y = (a * x + b) % 26;
            return ALPHABET[y];
        }
        
        // Обратное афинное преобразование
        function affineDecrypt(char, a, b) {
            const y = ALPHABET.indexOf(char);
            if (y === -1) return char;
            
            // Находим обратный элемент a⁻¹ mod 26
            let aInv = 0;
            for (let i = 0; i < 26; i++) {
                if ((a * i) % 26 === 1) {
                    aInv = i;
                    break;
                }
            }
            
            const x = (aInv * (y - b + 26)) % 26;
            return ALPHABET[x];
        }
        
        // Создание S-Box
        async function createSBox() {
            // Генерируем все возможные homophones
            const allHomophones = [];
            for (let i = 0; i < BASE64_CHARS.length; i++) {
                for (let j = 0; j < BASE64_CHARS.length; j++) {
                    allHomophones.push(BASE64_CHARS[i] + BASE64_CHARS[j]);
                }
            }
            
            // Генерируем все возможные биграммы
            const allBigrams = [];
            for (let i = 0; i < ALPHABET.length; i++) {
                for (let j = 0; j < ALPHABET.length; j++) {
                    allBigrams.push(ALPHABET[i] + ALPHABET[j]);
                }
            }
            
            // Перемешиваем homophones
            const shuffledHomophones = [...allHomophones].sort(() => Math.random() - 0.5);
            
            // Создаем S-Box
            const sBox = {};
            let homophoneIndex = 0;
            
            for (let i = 0; i < allBigrams.length; i++) {
                const bigram = allBigrams[i];
                const homophonesNeeded = i < 40 ? 7 : 6;
                
                sBox[bigram] = shuffledHomophones.slice(homophoneIndex, homophoneIndex + homophonesNeeded);
                homophoneIndex += homophonesNeeded;
            }
            
            return sBox;
        }
        
        // Создание обратного S-Box
        function createReverseSBox(sBox) {
            const reverse = {};
            for (const [bigram, homophones] of Object.entries(sBox)) {
                for (const homophone of homophones) {
                    reverse[homophone] = bigram;
                }
            }
            return reverse;
        }
        
        // Шифрование
        async function encrypt() {
            const a = parseInt(document.getElementById('a-param').value);
            const b = parseInt(document.getElementById('b-param').value);
            let plaintext = document.getElementById('plaintext').value.toUpperCase().replace(/[^A-Z]/g, '');
            
            if (!plaintext) {
                alert('Введите текст для шифрования');
                return;
            }
            
            // Проверяем, что a взаимно просто с 26
            if (gcd(a, 26) !== 1) {
                alert('Параметр a должен быть взаимно простым с 26');
                return;
            }
            
            // Применяем афинное преобразование
            let affineText = '';
            for (const char of plaintext) {
                affineText += affineEncrypt(char, a, b);
            }
            
            document.getElementById('affine-output').textContent = affineText;
            
            // Создаем S-Box если нужно
            if (!sBox) {
                sBox = await createSBox();
                reverseSBox = createReverseSBox(sBox);
            }
            
            // Добавляем padding если нужно
            if (affineText.length % 2 !== 0) {
                affineText += 'X';
            }
            
            // Применяем гомофонное шифрование
            let ciphertext = '';
            for (let i = 0; i < affineText.length; i += 2) {
                const bigram = affineText.substr(i, 2);
                if (sBox[bigram]) {
                    const randomIndex = Math.floor(Math.random() * sBox[bigram].length);
                    ciphertext += sBox[bigram][randomIndex];
                }
            }
            
            document.getElementById('ciphertext-output').textContent = ciphertext;
            document.getElementById('ciphertext').value = ciphertext;
        }
        
        // Дешифрование
        async function decrypt() {
            const a = parseInt(document.getElementById('a-param').value);
            const b = parseInt(document.getElementById('b-param').value);
            const ciphertext = document.getElementById('ciphertext').value;
            
            if (!ciphertext) {
                alert('Введите зашифрованный текст');
                return;
            }
            
            if (ciphertext.length % 2 !== 0) {
                alert('Длина зашифрованного текста должна быть четной');
                return;
            }
            
            // Создаем S-Box если нужно
            if (!sBox) {
                sBox = await createSBox();
                reverseSBox = createReverseSBox(sBox);
            }
            
            // Дешифруем гомофоны
            let affineText = '';
            for (let i = 0; i < ciphertext.length; i += 2) {
                const homophone = ciphertext.substr(i, 2);
                if (reverseSBox[homophone]) {
                    affineText += reverseSBox[homophone];
                } else {
                    affineText += '??';
                }
            }
            
            // Применяем обратное афинное преобразование
            let plaintext = '';
            for (const char of affineText) {
                plaintext += affineDecrypt(char, a, b);
            }
            
            document.getElementById('decrypted-output').textContent = plaintext;
        }
        
        // Нахождение НОД
        function gcd(a, b) {
            if (b === 0) return a;
            return gcd(b, a % b);
        }
    </script>
</body>
</html>
