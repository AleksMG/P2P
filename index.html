<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Corrected Homophonic Cipher</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a1a1a;
            color: #e0e0e0;
            line-height: 1.6;
        }
        h1, h2, h3 { color: #4caf50; }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #2d2d2d 0%, #1a1a1a 100%);
            border-radius: 10px;
        }
        .container { display: flex; flex-direction: column; gap: 25px; }
        .panel {
            background-color: #2d2d2d;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        .input-group { margin-bottom: 20px; }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #4caf50;
        }
        input, textarea, button, select {
            width: 100%;
            padding: 12px;
            border: 1px solid #444;
            border-radius: 6px;
            font-size: 16px;
            background-color: #333;
            color: #fff;
        }
        textarea {
            min-height: 120px;
            resize: vertical;
            font-family: monospace;
        }
        button {
            background-color: #4caf50;
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            padding: 14px;
            margin: 5px 0;
        }
        button:hover {
            background-color: #3d8b40;
            transform: translateY(-2px);
        }
        .output {
            background-color: #333;
            padding: 15px;
            border-radius: 6px;
            margin-top: 10px;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
        }
        .error { background-color: #ff6b6b; color: #fff; }
        .success { background-color: #4caf50; color: #fff; }
        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            background-color: #333;
            padding: 15px;
            border-radius: 6px;
        }
        .stat-item { text-align: center; padding: 10px; }
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #4caf50;
        }
        .flex-row { display: flex; gap: 20px; }
        .flex-row > div { flex: 1; }
        .analysis {
            background-color: #2c3e50;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }
        @media (max-width: 768px) {
            .flex-row { flex-direction: column; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Corrected Homophonic Cipher</h1>
        <p>Proper implementation with correct mathematical foundations</p>
    </div>
    
    <div class="container">
        <div class="panel">
            <h2>Cipher Parameters</h2>
            <div class="flex-row">
                <div class="input-group">
                    <label for="prime">Prime Number (must be > 255):</label>
                    <select id="prime">
                        <option value="257">257 (minimum)</option>
                        <option value="509">509</option>
                        <option value="1021">1021</option>
                        <option value="65521">65521</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="variables">Variables (n):</label>
                    <input type="number" id="variables" value="4" min="2" max="8">
                </div>
            </div>
            <button id="generateKey">Generate New Key</button>
            <div class="input-group">
                <label>Key Information:</label>
                <div class="output" id="keyInfo">Key not generated</div>
            </div>
        </div>
        
        <div class="panel">
            <h2>Encryption & Decryption</h2>
            <div class="input-group">
                <label for="plaintext">Input Data:</label>
                <textarea id="plaintext" placeholder="Enter data to encrypt">Test message</textarea>
            </div>
            
            <div class="flex-row">
                <button id="encryptBtn">Encrypt</button>
                <button id="decryptBtn">Decrypt</button>
            </div>
            
            <div class="input-group">
                <label>Ciphertext (hex):</label>
                <div class="output" id="ciphertextOutput"></div>
            </div>
            
            <div class="input-group">
                <label>Decrypted Result:</label>
                <div class="output" id="decryptedOutput"></div>
            </div>
            
            <div id="status"></div>
        </div>
        
        <div class="analysis">
            <h2>Mathematical Correctness</h2>
            <h3>Core Principles:</h3>
            <p>1. Prime number p MUST be greater than 255 (p > 255)</p>
            <p>2. Each byte b ∈ [0, 255] maps to equation: a₁x₁ + ... + aₙxₙ ≡ b mod p</p>
            <p>3. Coefficients aᵢ ∈ [1, p-1] (must be invertible for aₙ)</p>
            <p>4. Variables xᵢ ∈ [0, p-1]</p>
            
            <h3>Size Requirements:</h3>
            <p>• For p ∈ [256, 65535]: 2 bytes per number</p>
            <p>• For p ∈ [65536, 16777215]: 3 bytes per number</p>
            <p>• For p > 16777215: 4 bytes per number</p>
            
            <h3>Encryption Process:</h3>
            <p>1. For each byte b, get coefficients [a₁,...,aₙ]</p>
            <p>2. Generate random x₁,...,xₙ₋₁ ∈ [0, p-1]</p>
            <p>3. Compute xₙ = (b - Σaᵢxᵢ) × aₙ⁻¹ mod p</p>
            <p>4. Output all xᵢ as fixed-size values</p>
        </div>
        
        <div class="stats">
            <div class="stat-item">
                <div>Input Size</div>
                <div class="stat-value" id="inputSize">0 bytes</div>
            </div>
            <div class="stat-item">
                <div>Ciphertext Size</div>
                <div class="stat-value" id="outputSize">0 bytes</div>
            </div>
            <div class="stat-item">
                <div>Bytes per Homophone</div>
                <div class="stat-value" id="bytesPerHomophone">0</div>
            </div>
        </div>
    </div>

    <script>
        // DOM elements
        const primeSelect = document.getElementById('prime');
        const variablesInput = document.getElementById('variables');
        const generateKeyBtn = document.getElementById('generateKey');
        const keyInfoEl = document.getElementById('keyInfo');
        const plaintextInput = document.getElementById('plaintext');
        const encryptBtn = document.getElementById('encryptBtn');
        const ciphertextOutput = document.getElementById('ciphertextOutput');
        const decryptBtn = document.getElementById('decryptBtn');
        const decryptedOutput = document.getElementById('decryptedOutput');
        const inputSizeEl = document.getElementById('inputSize');
        const outputSizeEl = document.getElementById('outputSize');
        const bytesPerHomophoneEl = document.getElementById('bytesPerHomophone');
        const statusEl = document.getElementById('status');
        
        let currentKey = null;
        
        // Utility functions
        function getRandomInt(min, max) {
            const arr = new Uint32Array(1);
            window.crypto.getRandomValues(arr);
            return min + (arr[0] % (max - min + 1));
        }
        
        function gcd(a, b) {
            return b === 0 ? a : gcd(b, a % b);
        }
        
        function modInverse(a, mod) {
            if (gcd(a, mod) !== 1) return null;
            
            let [t, newT] = [0, 1];
            let [r, newR] = [mod, a];
            
            while (newR !== 0) {
                const quotient = Math.floor(r / newR);
                [t, newT] = [newT, t - quotient * newT];
                [r, newR] = [newR, r - quotient * newR];
            }
            
            return t < 0 ? t + mod : t;
        }
        
        function showStatus(message, type) {
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            setTimeout(() => statusEl.textContent = '', 5000);
        }
        
        function getBytesPerNumber(p) {
            if (p <= 255) return 1;
            if (p <= 65535) return 2;
            if (p <= 16777215) return 3;
            return 4;
        }
        
        function numberToBytes(number, byteSize) {
            const bytes = [];
            for (let i = 0; i < byteSize; i++) {
                bytes.push((number >> (8 * i)) & 0xFF);
            }
            return bytes;
        }
        
        function bytesToNumber(bytes) {
            let number = 0;
            for (let i = 0; i < bytes.length; i++) {
                number |= bytes[i] << (8 * i);
            }
            return number;
        }
        
        function numbersToHex(numbers, byteSize) {
            let hex = '';
            for (const number of numbers) {
                const bytes = numberToBytes(number, byteSize);
                hex += bytes.map(b => b.toString(16).padStart(2, '0')).join('');
            }
            return hex;
        }
        
        function hexToNumbers(hex, byteSize) {
            const numbers = [];
            const bytes = [];
            
            // Convert hex to bytes
            hex = hex.replace(/[^0-9a-fA-F]/g, '');
            for (let i = 0; i < hex.length; i += 2) {
                bytes.push(parseInt(hex.substr(i, 2), 16));
            }
            
            // Convert bytes to numbers
            for (let i = 0; i < bytes.length; i += byteSize) {
                const numberBytes = bytes.slice(i, i + byteSize);
                numbers.push(bytesToNumber(numberBytes));
            }
            
            return numbers;
        }
        
        function textToBytes(text) {
            const encoder = new TextEncoder();
            return Array.from(encoder.encode(text));
        }
        
        function bytesToText(bytes) {
            const decoder = new TextDecoder('utf-8');
            return decoder.decode(new Uint8Array(bytes));
        }
        
        // Key generation
        function generateKey() {
            const p = parseInt(primeSelect.value);
            const n = parseInt(variablesInput.value);
            
            if (p <= 255) {
                showStatus('Prime must be greater than 255', 'error');
                return;
            }
            
            const coefficients = [];
            const byteSize = getBytesPerNumber(p);
            
            for (let byteValue = 0; byteValue < 256; byteValue++) {
                const coeffs = [];
                
                // Generate first n-1 random coefficients
                for (let j = 0; j < n - 1; j++) {
                    coeffs.push(getRandomInt(1, p - 1));
                }
                
                // Generate invertible last coefficient
                let lastCoeff;
                do {
                    lastCoeff = getRandomInt(1, p - 1);
                } while (gcd(lastCoeff, p) !== 1);
                
                coeffs.push(lastCoeff);
                coefficients[byteValue] = coeffs;
            }
            
            currentKey = { p, n, coefficients, byteSize };
            
            keyInfoEl.textContent = `p=${p}, n=${n}, ${byteSize} byte(s) per number`;
            bytesPerHomophoneEl.textContent = `${byteSize} bytes`;
            showStatus('Key generated successfully', 'success');
        }
        
        // Encryption
        function encrypt() {
            if (!currentKey) {
                showStatus('Generate key first', 'error');
                return;
            }
            
            const text = plaintextInput.value;
            if (!text.trim()) {
                showStatus('Input is empty', 'error');
                return;
            }
            
            try {
                const inputBytes = textToBytes(text);
                const { p, n, coefficients, byteSize } = currentKey;
                const outputNumbers = [];
                
                for (const byte of inputBytes) {
                    const a = coefficients[byte];
                    const values = [];
                    
                    // Generate random values for first n-1 variables
                    for (let i = 0; i < n - 1; i++) {
                        values.push(getRandomInt(0, p - 1));
                    }
                    
                    // Calculate sum of first n-1 terms
                    let sum = 0;
                    for (let i = 0; i < n - 1; i++) {
                        sum = (sum + a[i] * values[i]) % p;
                    }
                    
                    // Solve for the last variable
                    const remainder = (byte - sum + p) % p;
                    const inv = modInverse(a[n-1], p);
                    
                    if (inv === null) {
                        throw new Error(`No inverse for coefficient ${a[n-1]} mod ${p}`);
                    }
                    
                    const lastValue = (remainder * inv) % p;
                    values.push(lastValue);
                    
                    // Verify the solution
                    let verificationSum = 0;
                    for (let i = 0; i < n; i++) {
                        verificationSum = (verificationSum + a[i] * values[i]) % p;
                    }
                    
                    if (verificationSum !== byte) {
                        throw new Error(`Verification failed for byte ${byte}`);
                    }
                    
                    outputNumbers.push(...values);
                }
                
                const inputSize = inputBytes.length;
                const outputSize = outputNumbers.length * byteSize;
                
                inputSizeEl.textContent = `${inputSize} bytes`;
                outputSizeEl.textContent = `${outputSize} bytes`;
                
                ciphertextOutput.textContent = numbersToHex(outputNumbers, byteSize);
                showStatus('Encryption successful', 'success');
                
            } catch (error) {
                showStatus(`Encryption error: ${error.message}`, 'error');
            }
        }
        
        // Decryption
        function decrypt() {
            if (!currentKey) {
                showStatus('Generate key first', 'error');
                return;
            }
            
            const hex = ciphertextOutput.textContent;
            if (!hex.trim()) {
                showStatus('Ciphertext is empty', 'error');
                return;
            }
            
            try {
                const { p, n, coefficients, byteSize } = currentKey;
                const numbers = hexToNumbers(hex, byteSize);
                
                if (numbers.length % n !== 0) {
                    throw new Error(`Ciphertext length not divisible by ${n}`);
                }
                
                const outputBytes = [];
                
                for (let i = 0; i < numbers.length; i += n) {
                    const values = numbers.slice(i, i + n);
                    let found = false;
                    
                    for (let byteValue = 0; byteValue < 256; byteValue++) {
                        const a = coefficients[byteValue];
                        let sum = 0;
                        
                        for (let j = 0; j < n; j++) {
                            sum = (sum + a[j] * values[j]) % p;
                        }
                        
                        if (sum === byteValue) {
                            outputBytes.push(byteValue);
                            found = true;
                            break;
                        }
                    }
                    
                    if (!found) {
                        throw new Error(`Cannot decrypt block at position ${i}`);
                    }
                }
                
                decryptedOutput.textContent = bytesToText(outputBytes);
                showStatus('Decryption successful', 'success');
                
            } catch (error) {
                showStatus(`Decryption error: ${error.message}`, 'error');
            }
        }
        
        // Event listeners
        generateKeyBtn.addEventListener('click', generateKey);
        encryptBtn.addEventListener('click', encrypt);
        decryptBtn.addEventListener('click', decrypt);
        
        // Initialize
        window.addEventListener('load', generateKey);
    </script>
</body>
</html>
