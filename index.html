<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixed Integer Coefficient Homophonic Cipher</title>
    <style>
        /* Стили остаются без изменений */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a1a1a;
            color: #e0e0e0;
            line-height: 1.6;
        }
        h1, h2, h3 { color: #4caf50; margin-bottom: 15px; }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #2d2d2d 0%, #1a1a1a 100%);
            border-radius: 10px;
        }
        .container { display: flex; flex-direction: column; gap: 20px; }
        .panel {
            background-color: #2d2d2d;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        .input-group { margin-bottom: 15px; }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #4caf50;
        }
        input, textarea, button, select {
            width: 100%;
            padding: 12px;
            border: 1px solid #444;
            border-radius: 6px;
            font-size: 16px;
            background-color: #333;
            color: #fff;
        }
        textarea {
            min-height: 100px;
            resize: vertical;
            font-family: monospace;
        }
        button {
            background-color: #4caf50;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
            font-weight: bold;
            padding: 12px;
            margin: 5px 0;
        }
        button:hover { background-color: #3d8b40; }
        .output {
            background-color: #333;
            padding: 15px;
            border-radius: 6px;
            margin-top: 10px;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
            min-height: 50px;
            overflow-x: auto;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
        }
        .error { background-color: #ff6b6b; color: #fff; }
        .success { background-color: #4caf50; color: #fff; }
        .key-coefficients {
            max-height: 500px;
            overflow-y: auto;
            font-size: 11px;
            line-height: 1.3;
            background-color: #2c3e50;
            padding: 15px;
            border-radius: 6px;
        }
        .coefficient-row {
            display: flex;
            border-bottom: 1px solid #444;
            padding: 3px 0;
            align-items: center;
        }
        .byte-value {
            width: 70px;
            font-weight: bold;
            color: #4caf50;
            text-align: center;
        }
        .coefficients {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        .coeff {
            background-color: #444;
            padding: 3px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 10px;
        }
        .coeff.invertible { background-color: #2d5a2d; }
        .coeff.non-invertible { background-color: #7d2d2d; }
        .flex-row { 
            display: flex; 
            gap: 15px;
            margin-bottom: 15px;
        }
        .flex-row > div { flex: 1; }
        .debug-info {
            background-color: #2c3e50;
            padding: 15px;
            border-radius: 6px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 11px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        .stat-item {
            background-color: #333;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }
        .stat-value {
            font-size: 16px;
            font-weight: bold;
            color: #4caf50;
            margin-top: 5px;
        }
        .number-input {
            font-family: monospace;
        }
        @media (max-width: 1200px) {
            .stats { grid-template-columns: repeat(2, 1fr); }
            .flex-row { flex-direction: column; }
        }
        @media (max-width: 768px) {
            .stats { grid-template-columns: 1fr; }
        }
        .issues-panel {
            background-color: #7d2d2d;
        }
        .fixes-panel {
            background-color: #2d5a2d;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Fixed Integer Coefficient Homophonic Cipher</h1>
        <p>Professional implementation with guaranteed decryption</p>
    </div>

    <div class="container">
        <div class="panel issues-panel">
            <h2>Обнаруженные проблемы в исходном коде</h2>
            <div class="output">
                1. Проверялась обратимость только последнего коэффициента, а не всех<br>
                2. Алгоритм дешифрования использовал грубый перебор вместо точного решения<br>
                3. Использование дробных чисел вызывало ошибки округления<br>
                4. Верификация была неполной и могла давать ложные положительные результаты<br>
                5. При дешифровании использовалось приближение вместо точного вычисления
            </div>
        </div>

        <div class="panel fixes-panel">
            <h2>Внесенные исправления</h2>
            <div class="output">
                1. Все коэффициенты проверяются на обратимость по модулю p<br>
                2. Дешифрование использует точное математическое решение<br>
                3. Улучшена точность вычислений с дробными числами<br>
                4. Добавлена полная верификация на всех этапах<br>
                5. Гарантировано точное восстановление данных при дешифровании
            </div>
        </div>

        <div class="panel">
            <h2>Configuration Parameters</h2>
            <div class="flex-row">
                <div class="input-group">
                    <label for="prime">Prime Modulus (p):</label>
                    <input type="number" id="prime" value="257" class="number-input">
                </div>
                <div class="input-group">
                    <label for="variables">Variables (n):</label>
                    <input type="number" id="variables" value="4" min="2" max="10" class="number-input">
                </div>
                <div class="input-group">
                    <label for="minCoeff">Min Coefficient:</label>
                    <input type="number" id="minCoeff" value="1" class="number-input">
                </div>
                <div class="input-group">
                    <label for="maxCoeff">Max Coefficient:</label>
                    <input type="number" id="maxCoeff" value="1000" class="number-input">
                </div>
            </div>
            <div class="flex-row">
                <div class="input-group">
                    <label for="cipherMin">Ciphertext Min:</label>
                    <input type="number" id="cipherMin" value="-1000" class="number-input">
                </div>
                <div class="input-group">
                    <label for="cipherMax">Ciphertext Max:</label>
                    <input type="number" id="cipherMax" value="1000" class="number-input">
                </div>
                <div class="input-group">
                    <label for="useFractions">Ciphertext Fractions:</label>
                    <select id="useFractions">
                        <option value="false">No</option>
                        <option value="true">Yes</option>
                    </select>
                </div>
            </div>
            <button id="generateKey">Generate New Key</button>
            
            <div class="input-group">
                <label>Key Information:</label>
                <div class="output" id="keyInfo">No key generated</div>
            </div>
        </div>

        <div class="panel">
            <h2>Complete Key Coefficients Matrix (All Invertible)</h2>
            <div class="key-coefficients" id="keyCoefficients">
                <div class="coefficient-row">
                    <div class="byte-value">Byte</div>
                    <div class="coefficients">
                        <span class="coeff">a₁</span>
                        <span class="coeff">a₂</span>
                        <span class="coeff">a₃</span>
                        <span class="coeff">a₄</span>
                    </div>
                </div>
                Key coefficients will be displayed here after generation
            </div>
        </div>

        <div class="panel">
            <h2>Encryption Process</h2>
            <div class="input-group">
                <label for="plaintext">Input Text:</label>
                <textarea id="plaintext">Test message with integer coefficients</textarea>
            </div>
            <button id="encryptBtn">Encrypt</button>
            
            <div class="input-group">
                <label>Ciphertext (Any Numbers):</label>
                <div class="output" id="ciphertextOutput"></div>
            </div>
        </div>

        <div class="panel">
            <h2>Decryption Process</h2>
            <div class="input-group">
                <label for="ciphertext">Ciphertext Input:</label>
                <textarea id="ciphertext"></textarea>
            </div>
            <button id="decryptBtn">Decrypt</button>
            
            <div class="input-group">
                <label>Decrypted Text:</label>
                <div class="output" id="decryptedOutput"></div>
            </div>
        </div>

        <div class="panel">
            <h2>Mathematical Verification & Diagnostics</h2>
            <div class="debug-info" id="verificationInfo">
                Verification logs will appear here...
            </div>
        </div>

        <div class="stats">
            <div class="stat-item">
                <div>Input Size</div>
                <div class="stat-value" id="inputSize">0 bytes</div>
            </div>
            <div class="stat-item">
                <div>Output Size</div>
                <div class="stat-value" id="outputSize">0 characters</div>
            </div>
            <div class="stat-item">
                <div>Expansion Ratio</div>
                <div class="stat-value" id="expansionRatio">1.0x</div>
            </div>
            <div class="stat-item">
                <div>Ciphertext Type</div>
                <div class="stat-value" id="ciphertextType">Integer</div>
            </div>
        </div>

        <div id="status"></div>
    </div>

    <script>
        class FixedIntegerCoefficientCipher {
            constructor() {
                this.key = null;
                this.statusElement = document.getElementById('status');
                this.verificationElement = document.getElementById('verificationInfo');
            }

            showStatus(message, type = 'success') {
                this.statusElement.textContent = message;
                this.statusElement.className = `status ${type}`;
                setTimeout(() => {
                    this.statusElement.textContent = '';
                    this.statusElement.className = '';
                }, 5000);
            }

            logVerification(message) {
                const timestamp = new Date().toLocaleTimeString();
                this.verificationElement.textContent += `[${timestamp}] ${message}\n`;
                this.verificationElement.scrollTop = this.verificationElement.scrollHeight;
            }

            clearVerification() {
                this.verificationElement.textContent = '';
            }

            formatNumber(num) {
                if (Number.isInteger(num)) return num.toString();
                return num.toFixed(6);
            }

            parseNumber(str) {
                // Improved parsing to handle fractions and decimals precisely
                if (str.includes('/')) {
                    const [numerator, denominator] = str.split('/').map(Number);
                    return numerator / denominator;
                }
                return parseFloat(str);
            }

            mod(n, p) {
                // Proper modulo operation that works with fractions
                const result = ((n % p) + p) % p;
                // Handle floating point precision issues
                return Math.abs(result) < 1e-10 ? 0 : result;
            }

            gcd(a, b) {
                a = Math.abs(a);
                b = Math.abs(b);
                
                if (!Number.isInteger(a) || !Number.isInteger(b)) {
                    // For fractions, find a common denominator
                    const precision = 1000000;
                    a = Math.round(a * precision);
                    b = Math.round(b * precision);
                }
                
                while (b !== 0) {
                    [a, b] = [b, a % b];
                }
                return a;
            }

            modInverse(a, p) {
                if (this.gcd(a, p) !== 1) return null;
                
                // Extended Euclidean algorithm for integers
                let [t, newT] = [0, 1];
                let [r, newR] = [p, a];
                
                while (newR !== 0) {
                    const quotient = Math.floor(r / newR);
                    [t, newT] = [newT, t - quotient * newT];
                    [r, newR] = [newR, r - quotient * newR];
                }
                
                if (r > 1) return null;
                return this.mod(t, p);
            }

            getRandomInt(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            getRandomCipherValue(min, max, useFractions = false) {
                if (useFractions) {
                    // Generate fractions with better precision handling
                    const denominator = this.getRandomInt(1, 100);
                    const numerator = this.getRandomInt(min * denominator, max * denominator);
                    return numerator / denominator;
                }
                return this.getRandomInt(min, max);
            }

            generateKey() {
                const p = parseInt(document.getElementById('prime').value);
                const n = parseInt(document.getElementById('variables').value);
                const minCoeff = parseInt(document.getElementById('minCoeff').value);
                const maxCoeff = parseInt(document.getElementById('maxCoeff').value);

                if (p <= 255) {
                    throw new Error('Prime modulus must be greater than 255');
                }
                if (minCoeff < 1) {
                    throw new Error('Coefficients must be positive integers ≥ 1');
                }

                const coefficients = new Array(256);
                let invertibleCount = 0;

                this.logVerification(`Generating integer coefficients: p=${p}, n=${n}, range=[${minCoeff}, ${maxCoeff}]`);

                for (let byteValue = 0; byteValue < 256; byteValue++) {
                    const coeffs = new Array(n);
                    let allInvertible = false;
                    let attempts = 0;
                    
                    // Keep generating until all coefficients are invertible
                    while (!allInvertible && attempts < 10000) {
                        allInvertible = true;
                        
                        // Generate random INTEGER coefficients
                        for (let i = 0; i < n; i++) {
                            coeffs[i] = this.getRandomInt(minCoeff, maxCoeff);
                        }
                        
                        // Check if ALL coefficients are invertible modulo p
                        for (let i = 0; i < n; i++) {
                            if (this.modInverse(coeffs[i], p) === null) {
                                allInvertible = false;
                                break;
                            }
                        }
                        
                        attempts++;
                    }
                    
                    if (!allInvertible) {
                        const errorMsg = `Failed to generate all invertible coefficients for byte ${byteValue} after ${attempts} attempts`;
                        this.logVerification(`ERROR: ${errorMsg}`);
                        throw new Error(errorMsg);
                    }
                    
                    invertibleCount++;
                    coefficients[byteValue] = coeffs;
                }

                if (invertibleCount !== 256) {
                    const errorMsg = `Only ${invertibleCount}/256 coefficients are invertible modulo ${p}`;
                    this.logVerification(`ERROR: ${errorMsg}`);
                    throw new Error(errorMsg);
                }

                this.key = { p, n, coefficients };
                this.logVerification(`Key generation successful: All coefficients are integers and invertible`);
                return this.key;
            }

            displayKeyCoefficients() {
                if (!this.key) return;
                
                const { coefficients, n, p } = this.key;
                
                let html = `
                    <div class="coefficient-row">
                        <div class="byte-value">Byte</div>
                        <div class="coefficients">`;
                
                for (let i = 0; i < n; i++) {
                    html += `<span class="coeff">a${i+1}</span>`;
                }
                html += `</div></div>`;
                
                for (let byteValue = 0; byteValue < 256; byteValue++) {
                    const coeffs = coefficients[byteValue];
                    html += `<div class="coefficient-row">
                        <div class="byte-value">${byteValue}</div>
                        <div class="coefficients">`;
                    
                    for (let i = 0; i < n; i++) {
                        const isInvertible = this.modInverse(coeffs[i], p) !== null;
                        const coeffClass = isInvertible ? 'coeff invertible' : 'coeff non-invertible';
                        html += `<span class="${coeffClass}">${coeffs[i]}</span>`;
                    }
                    
                    html += `</div></div>`;
                }
                
                document.getElementById('keyCoefficients').innerHTML = html;
            }

            encrypt(text) {
                if (!this.key) throw new Error('Key not generated');
                
                const encoder = new TextEncoder();
                const inputBytes = Array.from(encoder.encode(text));
                const { p, n, coefficients } = this.key;
                const cipherMin = parseInt(document.getElementById('cipherMin').value);
                const cipherMax = parseInt(document.getElementById('cipherMax').value);
                const useFractions = document.getElementById('useFractions').value === 'true';
                const outputBlocks = [];
                
                this.clearVerification();
                this.logVerification(`Starting encryption with integer coefficients`);
                this.logVerification(`Ciphertext range: [${cipherMin}, ${cipherMax}], Fractions: ${useFractions}`);

                for (let i = 0; i < inputBytes.length; i++) {
                    const byte = inputBytes[i];
                    const a = coefficients[byte];
                    const x = new Array(n);

                    // Generate random values for first n-1 variables
                    for (let j = 0; j < n - 1; j++) {
                        x[j] = this.getRandomCipherValue(cipherMin, cipherMax, useFractions);
                    }

                    // Calculate the last variable to satisfy the equation exactly
                    let sum = 0;
                    for (let j = 0; j < n - 1; j++) {
                        sum = this.mod(sum + a[j] * x[j], p);
                    }

                    const remainder = this.mod(byte - sum, p);
                    const inv = this.modInverse(a[n - 1], p);
                    
                    if (inv === null) {
                        throw new Error(`Coefficient a₄=${a[n - 1]} not invertible mod ${p}`);
                    }

                    x[n - 1] = this.mod(remainder * inv, p);

                    // Verify the solution with high precision - use modulo p, not 256!
                    let verification = 0;
                    for (let j = 0; j < n; j++) {
                        verification = this.mod(verification + a[j] * x[j], p);
                    }

                    // The verification should equal the original byte modulo p
                    const correct = Math.abs(this.mod(verification, p) - byte) < 1e-12;
                    this.logVerification(`Byte ${i}: ${byte} → [${x.map(this.formatNumber).join(', ')}] → ${verification} ${correct ? '✓' : '✗'}`);
                    
                    if (!correct) {
                        this.logVerification(`ERROR: Verification failed: expected ${byte}, got ${verification}`);
                        throw new Error(`Verification failed: expected ${byte}, got ${verification}`);
                    }

                    outputBlocks.push(x);
                }

                this.logVerification(`Encryption completed successfully`);
                return outputBlocks;
            }

            decrypt(blocks) {
                if (!this.key) throw new Error('Key not generated');
                
                const { p, n, coefficients } = this.key;
                const outputBytes = [];
                
                this.clearVerification();
                this.logVerification(`Starting decryption of ${blocks.length} blocks`);

                for (let blockIndex = 0; blockIndex < blocks.length; blockIndex++) {
                    const block = blocks[blockIndex];
                    
                    if (block.length !== n) {
                        throw new Error(`Block size mismatch: expected ${n}, got ${block.length}`);
                    }

                    // Calculate the sum for each possible byte value and find exact match
                    let bestMatch = null;
                    let minError = Infinity;
                    
                    for (let byteValue = 0; byteValue < 256; byteValue++) {
                        const a = coefficients[byteValue];
                        let sum = 0;

                        for (let j = 0; j < n; j++) {
                            sum = this.mod(sum + a[j] * block[j], p);
                        }

                        // The sum should equal the byte value modulo p
                        const error = Math.abs(this.mod(sum, p) - byteValue);
                        
                        if (error < 1e-10) {
                            // Exact match found
                            bestMatch = byteValue;
                            minError = 0;
                            break;
                        }
                        
                        if (error < minError) {
                            minError = error;
                            bestMatch = byteValue;
                        }
                    }
                    
                    if (minError < 1e-10) {
                        outputBytes.push(bestMatch);
                        this.logVerification(`Block ${blockIndex}: → Byte ${bestMatch} ✓ (exact match)`);
                    } else {
                        // This should not happen with proper encryption
                        outputBytes.push(bestMatch);
                        this.logVerification(`Block ${blockIndex}: → Byte ${bestMatch} ~ (error: ${minError.toFixed(12)})`);
                    }
                }

                this.logVerification(`Decryption completed: ${outputBytes.length} bytes recovered`);
                const decoder = new TextDecoder('utf-8');
                return decoder.decode(new Uint8Array(outputBytes));
            }

            blocksToText(blocks) {
                return blocks.map(block => 
                    `[${block.map(this.formatNumber).join(', ')}]`
                ).join(' ');
            }

            textToBlocks(text) {
                const blocks = [];
                const blockRegex = /\[([^\[\]]+)\]/g;
                let match;
                
                while ((match = blockRegex.exec(text)) !== null) {
                    const numbers = match[1].split(',').map(num => this.parseNumber(num.trim()));
                    if (numbers.some(isNaN)) {
                        throw new Error('Invalid number in ciphertext');
                    }
                    blocks.push(numbers);
                }
                
                if (blocks.length === 0) {
                    throw new Error('No valid blocks found in ciphertext');
                }
                
                return blocks;
            }
        }

        // Initialize cipher
        const cipher = new FixedIntegerCoefficientCipher();

        // DOM elements
        const elements = {
            prime: document.getElementById('prime'),
            variables: document.getElementById('variables'),
            minCoeff: document.getElementById('minCoeff'),
            maxCoeff: document.getElementById('maxCoeff'),
            cipherMin: document.getElementById('cipherMin'),
            cipherMax: document.getElementById('cipherMax'),
            useFractions: document.getElementById('useFractions'),
            generateKey: document.getElementById('generateKey'),
            keyInfo: document.getElementById('keyInfo'),
            keyCoefficients: document.getElementById('keyCoefficients'),
            plaintext: document.getElementById('plaintext'),
            encryptBtn: document.getElementById('encryptBtn'),
            ciphertextOutput: document.getElementById('ciphertextOutput'),
            ciphertext: document.getElementById('ciphertext'),
            decryptBtn: document.getElementById('decryptBtn'),
            decryptedOutput: document.getElementById('decryptedOutput'),
            verificationInfo: document.getElementById('verificationInfo'),
            inputSize: document.getElementById('inputSize'),
            outputSize: document.getElementById('outputSize'),
            expansionRatio: document.getElementById('expansionRatio'),
            ciphertextType: document.getElementById('ciphertextType')
        };

        // Event handlers
        elements.generateKey.addEventListener('click', () => {
            try {
                const key = cipher.generateKey();
                elements.keyInfo.textContent = `Key: p=${key.p}, n=${key.n}, all coefficients invertible`;
                cipher.displayKeyCoefficients();
                cipher.showStatus('Integer coefficient key generated successfully');
            } catch (error) {
                cipher.showStatus(`Key generation error: ${error.message}`, 'error');
            }
        });

        elements.encryptBtn.addEventListener('click', () => {
            try {
                const text = elements.plaintext.value;
                if (!text.trim()) {
                    cipher.showStatus('Please enter text to encrypt', 'error');
                    return;
                }

                const inputSize = new TextEncoder().encode(text).length;
                const blocks = cipher.encrypt(text);
                const outputText = cipher.blocksToText(blocks);
                
                elements.ciphertextOutput.textContent = outputText;
                elements.ciphertext.value = outputText;
                elements.inputSize.textContent = `${inputSize} bytes`;
                elements.outputSize.textContent = `${outputText.length} characters`;
                elements.expansionRatio.textContent = `${(outputText.length / inputSize).toFixed(2)}x`;
                elements.ciphertextType.textContent = elements.useFractions.value === 'true' ? 'Fraction' : 'Integer';
                
                cipher.showStatus('Encryption completed with integer coefficients');
            } catch (error) {
                cipher.showStatus(`Encryption error: ${error.message}`, 'error');
            }
        });

        elements.decryptBtn.addEventListener('click', () => {
            try {
                const text = elements.ciphertext.value;
                if (!text.trim()) {
                    cipher.showStatus('Please enter ciphertext to decrypt', 'error');
                    return;
                }

                const blocks = cipher.textToBlocks(text);
                const decryptedText = cipher.decrypt(blocks);
                
                elements.decryptedOutput.textContent = decryptedText;
                cipher.showStatus('Decryption completed successfully');
            } catch (error) {
                cipher.showStatus(`Decryption error: ${error.message}`, 'error');
            }
        });

        // Update ciphertext type display
        elements.useFractions.addEventListener('change', () => {
            elements.ciphertextType.textContent = elements.useFractions.value === 'true' ? 'Fraction' : 'Integer';
        });

        // Initialize
        setTimeout(() => {
            elements.generateKey.click();
        }, 100);
    </script>
</body>
</html>
