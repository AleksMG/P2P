<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Homophonic Cipher</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a1a1a;
            color: #e0e0e0;
            line-height: 1.6;
        }
        h1, h2, h3 { color: #4caf50; }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #2d2d2d 0%, #1a1a1a 100%);
            border-radius: 10px;
        }
        .container { display: flex; flex-direction: column; gap: 25px; }
        .panel {
            background-color: #2d2d2d;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        .input-group { margin-bottom: 20px; }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #4caf50;
        }
        input, textarea, button, select {
            width: 100%;
            padding: 12px;
            border: 1px solid #444;
            border-radius: 6px;
            font-size: 16px;
            background-color: #333;
            color: #fff;
        }
        textarea {
            min-height: 120px;
            resize: vertical;
            font-family: monospace;
        }
        button {
            background-color: #4caf50;
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            padding: 14px;
            margin: 5px 0;
        }
        button:hover {
            background-color: #3d8b40;
            transform: translateY(-2px);
        }
        .output {
            background-color: #333;
            padding: 15px;
            border-radius: 6px;
            margin-top: 10px;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
        }
        .error { background-color: #ff6b6b; color: #fff; }
        .success { background-color: #4caf50; color: #fff; }
        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            background-color: #333;
            padding: 15px;
            border-radius: 6px;
        }
        .stat-item { text-align: center; padding: 10px; }
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #4caf50;
        }
        .flex-row { display: flex; gap: 20px; }
        .flex-row > div { flex: 1; }
        @media (max-width: 768px) {
            .flex-row { flex-direction: column; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Professional Homophonic Cipher</h1>
        <p>Advanced implementation with automatic format detection</p>
    </div>
    
    <div class="container">
        <div class="panel">
            <h2>Cipher Parameters</h2>
            <div class="flex-row">
                <div class="input-group">
                    <label for="prime">Prime Number (p ≥ 257):</label>
                    <select id="prime">
                        <option value="257">257</option>
                        <option value="251" selected>251 (optimal)</option>
                        <option value="509">509</option>
                        <option value="65521">65521</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="variables">Variables (n):</label>
                    <input type="number" id="variables" value="4" min="2" max="8">
                </div>
            </div>
            <button id="generateKey">Generate New Key</button>
            <div class="input-group">
                <label>Key Fingerprint:</label>
                <div class="output" id="keyDisplay">Key not generated</div>
            </div>
        </div>
        
        <div class="panel">
            <h2>Encryption</h2>
            <div class="input-group">
                <label for="plaintext">Input Data (text/hex/base64):</label>
                <textarea id="plaintext" placeholder="Enter data to encrypt">Hello World! Привет мир!</textarea>
            </div>
            <button id="encryptBtn">Encrypt</button>
            
            <div class="input-group">
                <label>Encrypted Result (hex, no spaces):</label>
                <div class="output" id="ciphertextOutput"></div>
            </div>
        </div>
        
        <div class="panel">
            <h2>Decryption</h2>
            <div class="input-group">
                <label for="ciphertext">Ciphertext (hex, no spaces):</label>
                <textarea id="ciphertext" placeholder="Enter ciphertext to decrypt"></textarea>
            </div>
            <button id="decryptBtn">Decrypt</button>
            
            <div class="input-group">
                <label>Decrypted Result:</label>
                <div class="output" id="decryptedOutput"></div>
            </div>
            <div id="status"></div>
        </div>
        
        <div class="stats">
            <div class="stat-item">
                <div>Input Size</div>
                <div class="stat-value" id="inputSize">0 bytes</div>
            </div>
            <div class="stat-item">
                <div>Ciphertext Size</div>
                <div class="stat-value" id="outputSize">0 bytes</div>
            </div>
            <div class="stat-item">
                <div>Expansion</div>
                <div class="stat-value" id="expansionRatio">1.0x</div>
            </div>
        </div>
    </div>

    <script>
        // DOM elements
        const primeSelect = document.getElementById('prime');
        const variablesInput = document.getElementById('variables');
        const generateKeyBtn = document.getElementById('generateKey');
        const keyDisplay = document.getElementById('keyDisplay');
        const plaintextInput = document.getElementById('plaintext');
        const encryptBtn = document.getElementById('encryptBtn');
        const ciphertextOutput = document.getElementById('ciphertextOutput');
        const ciphertextInput = document.getElementById('ciphertext');
        const decryptBtn = document.getElementById('decryptBtn');
        const decryptedOutput = document.getElementById('decryptedOutput');
        const inputSizeEl = document.getElementById('inputSize');
        const outputSizeEl = document.getElementById('outputSize');
        const expansionRatioEl = document.getElementById('expansionRatio');
        const statusEl = document.getElementById('status');
        
        let currentKey = null;
        
        // Utility functions
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        function gcd(a, b) {
            return b === 0 ? a : gcd(b, a % b);
        }
        
        function modInverse(a, mod) {
            if (gcd(a, mod) !== 1) return null;
            let [t, newT] = [0, 1];
            let [r, newR] = [mod, a];
            
            while (newR !== 0) {
                const quotient = Math.floor(r / newR);
                [t, newT] = [newT, t - quotient * newT];
                [r, newR] = [newR, r - quotient * newR];
            }
            return t < 0 ? t + mod : t;
        }
        
        function showStatus(message, type) {
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            setTimeout(() => statusEl.textContent = '', 5000);
        }
        
        // Detect input format and convert to bytes
        function inputToBytes(input) {
            input = input.trim();
            
            // Hex detection (only hex characters, even length)
            if (/^[0-9a-fA-F]+$/.test(input) && input.length % 2 === 0) {
                const bytes = [];
                for (let i = 0; i < input.length; i += 2) {
                    bytes.push(parseInt(input.substr(i, 2), 16));
                }
                return bytes;
            }
            
            // Base64 detection
            if (/^[A-Za-z0-9+/]*={0,2}$/.test(input) && input.length % 4 === 0) {
                try {
                    const binary = atob(input);
                    return Array.from(binary, c => c.charCodeAt(0));
                } catch (e) {
                    // Not valid base64
                }
            }
            
            // Default to text (UTF-8)
            const encoder = new TextEncoder();
            return Array.from(encoder.encode(input));
        }
        
        // Convert bytes to output format
        function bytesToHex(bytes) {
            return bytes.map(b => b.toString(16).padStart(2, '0')).join('');
        }
        
        function bytesToText(bytes) {
            const decoder = new TextDecoder('utf-8');
            return decoder.decode(new Uint8Array(bytes));
        }
        
        // Key generation
        function generateKey() {
            const p = parseInt(primeSelect.value);
            const n = parseInt(variablesInput.value);
            
            if (p <= 255) {
                showStatus('Prime must be > 255', 'error');
                return;
            }
            
            const coefficients = [];
            for (let byteValue = 0; byteValue < 256; byteValue++) {
                const coeffs = [];
                for (let j = 0; j < n - 1; j++) {
                    coeffs.push(getRandomInt(1, p - 1));
                }
                
                let lastCoeff;
                do {
                    lastCoeff = getRandomInt(1, p - 1);
                } while (modInverse(lastCoeff, p) === null);
                
                coeffs.push(lastCoeff);
                coefficients[byteValue] = coeffs;
            }
            
            currentKey = { p, n, coefficients };
            keyDisplay.textContent = `p=${p}, n=${n}, fingerprint: ${bytesToHex(coefficients[0]).substring(0, 16)}...`;
            showStatus('New key generated', 'success');
        }
        
        // Encryption
        function encrypt() {
            if (!currentKey) {
                showStatus('Generate key first', 'error');
                return;
            }
            
            const input = plaintextInput.value;
            if (!input.trim()) {
                showStatus('Input is empty', 'error');
                return;
            }
            
            try {
                const inputBytes = inputToBytes(input);
                const { p, n, coefficients } = currentKey;
                const outputBytes = [];
                
                for (const byte of inputBytes) {
                    const a = coefficients[byte];
                    const values = [];
                    
                    for (let i = 0; i < n - 1; i++) {
                        values.push(getRandomInt(0, p - 1));
                    }
                    
                    let sum = values.reduce((s, val, i) => (s + a[i] * val) % p, 0);
                    const remainder = (byte - sum + p) % p;
                    const inv = modInverse(a[n-1], p);
                    
                    if (inv === null) {
                        throw new Error(`No inverse for coefficient ${a[n-1]} mod ${p}`);
                    }
                    
                    values.push((remainder * inv) % p);
                    outputBytes.push(...values);
                }
                
                const inputSize = inputBytes.length;
                const outputSize = outputBytes.length;
                
                inputSizeEl.textContent = `${inputSize} bytes`;
                outputSizeEl.textContent = `${outputSize} bytes`;
                expansionRatioEl.textContent = `${(outputSize / inputSize).toFixed(2)}x`;
                
                ciphertextOutput.textContent = bytesToHex(outputBytes);
                ciphertextInput.value = bytesToHex(outputBytes);
                
                showStatus('Encryption successful', 'success');
            } catch (error) {
                showStatus(`Encryption error: ${error.message}`, 'error');
            }
        }
        
        // Decryption
        function decrypt() {
            if (!currentKey) {
                showStatus('Generate key first', 'error');
                return;
            }
            
            const ciphertext = ciphertextInput.value.trim();
            if (!ciphertext) {
                showStatus('Ciphertext is empty', 'error');
                return;
            }
            
            try {
                const cipherBytes = inputToBytes(ciphertext);
                const { p, n, coefficients } = currentKey;
                
                if (cipherBytes.length % n !== 0) {
                    throw new Error(`Ciphertext length ${cipherBytes.length} not divisible by ${n}`);
                }
                
                const outputBytes = [];
                for (let i = 0; i < cipherBytes.length; i += n) {
                    const values = cipherBytes.slice(i, i + n);
                    let found = false;
                    
                    for (let byteValue = 0; byteValue < 256; byteValue++) {
                        const a = coefficients[byteValue];
                        const sum = values.reduce((s, val, j) => (s + a[j] * val) % p, 0);
                        
                        if (sum === byteValue) {
                            outputBytes.push(byteValue);
                            found = true;
                            break;
                        }
                    }
                    
                    if (!found) {
                        throw new Error(`Cannot decrypt block at position ${i}`);
                    }
                }
                
                decryptedOutput.textContent = bytesToText(outputBytes);
                showStatus('Decryption successful', 'success');
            } catch (error) {
                showStatus(`Decryption error: ${error.message}`, 'error');
            }
        }
        
        // Event listeners
        generateKeyBtn.addEventListener('click', generateKey);
        encryptBtn.addEventListener('click', encrypt);
        decryptBtn.addEventListener('click', decrypt);
        
        // Initialize
        window.addEventListener('load', generateKey);
    </script>
</body>
</html>
